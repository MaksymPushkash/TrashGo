"""
Order Service - Business logic layer.

This module contains business logic for order operations.
It validates rules, transforms data, and calls the repository.

Uses custom exceptions for consistent error handling.
"""

from typing import Optional
from backend.app.dependencies import DbSession
from backend.app.models.order_model import Orders, OrderStatus
from backend.app.repository.order_repo import order_repo
from backend.app.schemas.order_schema import OrderRead, OrderCreate
from backend.app.utils.exceptions import NotFoundException


def create_order(db: DbSession, order_data: OrderCreate, user_id: str) -> Orders:
    """
    1. Create Order model with user_id
    2. UUID is auto-generated by the model
    3. Save to database via repository
    """
    new_order = Orders(
        user_id=user_id,
        courier_id=order_data.courier_id,
        status=OrderStatus.CREATED,
        description=order_data.description
    )

    return order_repo.create(db, new_order)


def get_order_by_id(db: DbSession, order_id: str) -> Optional[OrderRead]:
    order = order_repo.get(db, order_id)

    if not order:
        return None
    return OrderRead.model_validate(order)


def get_order_by_id_or_raise(db: DbSession, order_id: str) -> OrderRead:
    order = order_repo.get(db, order_id)

    if not order:
        raise NotFoundException(f"Order with id '{order_id}' not found")
    return OrderRead.model_validate(order)


def list_orders(db: DbSession, skip: int = 0, limit: int = 100) -> list[OrderRead]:
    orders = order_repo.get_all(db, skip=skip, limit=limit)
    return [OrderRead.model_validate(o) for o in orders]


def list_user_orders(db: DbSession, user_id: str, skip: int = 0, limit: int = 100) -> list[OrderRead]:
    orders = order_repo.get_by_user(db, user_id, skip=skip, limit=limit)
    return [OrderRead.model_validate(o) for o in orders]


def list_courier_orders(db: DbSession, courier_id: str, skip: int = 0, limit: int = 100) -> list[OrderRead]:
    orders = order_repo.get_by_courier(db, courier_id, skip=skip, limit=limit)
    return [OrderRead.model_validate(o) for o in orders]


def update_order_status(db: DbSession, order_id: str, new_status: OrderStatus) -> Optional[OrderRead]:
    order = order_repo.get(db, order_id)

    if not order:
        return None
    
    order.status = new_status

    updated_order = order_repo.update(db, order)
    return OrderRead.model_validate(updated_order)


def update_order_status_or_raise(db: DbSession, order_id: str, new_status: OrderStatus) -> OrderRead:
    order = order_repo.get(db, order_id)

    if not order:
        raise NotFoundException(f"Order with id '{order_id}' not found")
    
    order.status = new_status

    updated_order = order_repo.update(db, order)
    return OrderRead.model_validate(updated_order)


def assign_courier(db: DbSession, order_id: str, courier_id: str) -> Optional[OrderRead]:
    order = order_repo.get(db, order_id)

    if not order:
        return None
    
    order.courier_id = courier_id
    order.status = OrderStatus.ASSIGNED

    updated_order = order_repo.update(db, order)
    return OrderRead.model_validate(updated_order)


def assign_courier_or_raise(db: DbSession, order_id: str, courier_id: str) -> OrderRead:
    order = order_repo.get(db, order_id)

    if not order:
        raise NotFoundException(f"Order with id '{order_id}' not found")
    
    order.courier_id = courier_id
    order.status = OrderStatus.ASSIGNED

    updated_order = order_repo.update(db, order)
    return OrderRead.model_validate(updated_order)


def delete_order(db: DbSession, order_id: str) -> bool:
    return order_repo.delete(db, order_id)


def delete_order_or_raise(db: DbSession, order_id: str) -> None:
    deleted = order_repo.delete(db, order_id)
    if not deleted:
        raise NotFoundException(f"Order with id '{order_id}' not found")
